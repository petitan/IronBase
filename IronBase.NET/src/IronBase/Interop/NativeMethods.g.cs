// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace IronBase.Interop
{
    internal static unsafe partial class NativeMethods
    {
#if IRONBASE_WINDOWS
        const string __DllName = "ironbase_ffi.dll";
#elif IRONBASE_LINUX
        const string __DllName = "libironbase_ffi.so";
#else
        const string __DllName = "ironbase_ffi";
#endif
        





        /// <summary>
        ///  Get the last error message
        ///
        ///  Returns a pointer to a null-terminated UTF-8 string.
        ///  The pointer is valid until the next FFI call on the same thread.
        ///  Returns null if no error has occurred.
        ///
        ///  # Safety
        ///  The returned pointer must not be freed by the caller.
        ///  The pointer is only valid until the next FFI call on the same thread.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_get_last_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_get_last_error();

        /// <summary>
        ///  Clear the last error message
        ///
        ///  Call this before a sequence of operations if you want to check
        ///  for errors after the sequence.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_clear_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_clear_error();

        /// <summary>
        ///  Check if an error occurred
        ///
        ///  Returns 1 if there is an error message, 0 otherwise.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_has_error", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_has_error();

        /// <summary>
        ///  Open a database file
        ///
        ///  # Parameters
        ///  - `path`: Path to the database file (UTF-8 null-terminated string)
        ///  - `out_handle`: Pointer to receive the database handle
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure (check `ironbase_get_last_error()` for details)
        ///
        ///  # Safety
        ///  - `path` must be a valid null-terminated UTF-8 string
        ///  - `out_handle` must be a valid pointer to a DbHandle
        ///  - The returned handle must be closed with `ironbase_close()`
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_open", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_open(byte* path, DatabaseHandle** out_handle);

        /// <summary>
        ///  Open a database file with specific durability mode
        ///
        ///  # Parameters
        ///  - `path`: Path to the database file (UTF-8 null-terminated string)
        ///  - `durability_mode`: 0=Safe, 1=Batch, 2=Unsafe
        ///  - `batch_size`: Batch size for Batch mode (ignored for other modes)
        ///  - `out_handle`: Pointer to receive the database handle
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_open_with_durability", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_open_with_durability(byte* path, int durability_mode, uint batch_size, DatabaseHandle** out_handle);

        /// <summary>
        ///  Close a database handle
        ///
        ///  This flushes all pending data and releases resources.
        ///  After this call, the handle is invalid and must not be used.
        ///
        ///  # Parameters
        ///  - `handle`: The database handle to close
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        ///
        ///  # Safety
        ///  - The handle must have been created by `ironbase_open()`
        ///  - The handle must not be used after this call
        ///  - It is safe to call with a null handle (no-op)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_close", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_close(DatabaseHandle* handle);

        /// <summary>
        ///  Flush all pending data to disk
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_flush", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_flush(DatabaseHandle* handle);

        /// <summary>
        ///  Checkpoint the database (clear WAL)
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_checkpoint", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_checkpoint(DatabaseHandle* handle);

        /// <summary>
        ///  Get database statistics as JSON
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///
        ///  # Returns
        ///  - Pointer to a JSON string (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_stats", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_stats(DatabaseHandle* handle);

        /// <summary>
        ///  Get the database file path
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///
        ///  # Returns
        ///  - Pointer to the path string (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_path", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_path(DatabaseHandle* handle);

        /// <summary>
        ///  Compact the database (remove tombstones)
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `out_stats`: Pointer to receive compaction stats JSON (optional, can be null)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_compact", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_compact(DatabaseHandle* handle, byte** out_stats);

        /// <summary>
        ///  List all collections in the database
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///
        ///  # Returns
        ///  - JSON array of collection names (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_list_collections", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_list_collections(DatabaseHandle* handle);

        /// <summary>
        ///  Drop a collection from the database
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `name`: Collection name (UTF-8 null-terminated string)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_drop_collection", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_drop_collection(DatabaseHandle* handle, byte* name);

        /// <summary>
        ///  Get or create a collection
        ///
        ///  # Parameters
        ///  - `db_handle`: The database handle
        ///  - `name`: Collection name (UTF-8 null-terminated string)
        ///  - `out_handle`: Pointer to receive the collection handle
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        ///
        ///  # Safety
        ///  - The returned handle must be released with `ironbase_collection_release()`
        ///  - The database handle must remain valid while the collection handle is in use
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_collection", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_collection(DatabaseHandle* db_handle, byte* name, CollectionHandle** out_handle);

        /// <summary>
        ///  Release a collection handle
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle to release
        ///
        ///  # Safety
        ///  - The handle must have been created by `ironbase_collection()`
        ///  - The handle must not be used after this call
        ///  - It is safe to call with a null handle (no-op)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_collection_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_collection_release(CollectionHandle* handle);

        /// <summary>
        ///  Get the collection name
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///
        ///  # Returns
        ///  - Pointer to the name string (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_collection_name", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_collection_name(CollectionHandle* handle);

        /// <summary>
        ///  Count documents in the collection
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string (use "{}" for all documents)
        ///  - `out_count`: Pointer to receive the count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_count_documents", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_count_documents(CollectionHandle* handle, byte* query_json, ulong* out_count);

        /// <summary>
        ///  Get distinct values for a field
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `field`: Field name (UTF-8 null-terminated string)
        ///  - `query_json`: Query filter as JSON string (use "{}" for all documents)
        ///
        ///  # Returns
        ///  - JSON array of distinct values (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_distinct", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_distinct(CollectionHandle* handle, byte* field, byte* query_json);

        /// <summary>
        ///  Insert one document
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `document_json`: Document as JSON string
        ///  - `out_id`: Pointer to receive the inserted ID as JSON string
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_insert_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_insert_one(CollectionHandle* handle, byte* document_json, byte** out_id);

        /// <summary>
        ///  Insert many documents
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `documents_json`: JSON array of documents
        ///  - `out_result`: Pointer to receive result JSON (inserted_count, inserted_ids)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_insert_many", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_insert_many(CollectionHandle* handle, byte* documents_json, byte** out_result);

        /// <summary>
        ///  Find documents
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///
        ///  # Returns
        ///  - JSON array of documents (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_find", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_find(CollectionHandle* handle, byte* query_json);

        /// <summary>
        ///  Find one document
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///
        ///  # Returns
        ///  - JSON document (caller must free with `ironbase_free_string()`)
        ///  - Null if not found or on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_find_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_find_one(CollectionHandle* handle, byte* query_json);

        /// <summary>
        ///  Find documents with options (projection, sort, limit, skip)
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `options_json`: Options as JSON: {"projection": {...}, "sort": [[field, 1/-1], ...], "limit": n, "skip": n}
        ///
        ///  # Returns
        ///  - JSON array of documents (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_find_with_options", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_find_with_options(CollectionHandle* handle, byte* query_json, byte* options_json);

        /// <summary>
        ///  Update one document
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `update_json`: Update operations as JSON string
        ///  - `out_matched`: Pointer to receive matched count
        ///  - `out_modified`: Pointer to receive modified count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_update_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_update_one(CollectionHandle* handle, byte* query_json, byte* update_json, ulong* out_matched, ulong* out_modified);

        /// <summary>
        ///  Update many documents
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `update_json`: Update operations as JSON string
        ///  - `out_matched`: Pointer to receive matched count
        ///  - `out_modified`: Pointer to receive modified count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_update_many", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_update_many(CollectionHandle* handle, byte* query_json, byte* update_json, ulong* out_matched, ulong* out_modified);

        /// <summary>
        ///  Delete one document
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `out_deleted`: Pointer to receive deleted count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_delete_one", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_delete_one(CollectionHandle* handle, byte* query_json, ulong* out_deleted);

        /// <summary>
        ///  Delete many documents
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `out_deleted`: Pointer to receive deleted count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_delete_many", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_delete_many(CollectionHandle* handle, byte* query_json, ulong* out_deleted);

        /// <summary>
        ///  Create an index on a field
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `field`: Field name to index (UTF-8 null-terminated string)
        ///  - `unique`: Whether the index enforces uniqueness (1 = unique, 0 = not unique)
        ///  - `out_name`: Pointer to receive the index name (optional)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_create_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_create_index(CollectionHandle* handle, byte* field, int unique, byte** out_name);

        /// <summary>
        ///  Create a compound index on multiple fields
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `fields_json`: JSON array of field names (e.g., ["country", "city"])
        ///  - `unique`: Whether the index enforces uniqueness
        ///  - `out_name`: Pointer to receive the index name (optional)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_create_compound_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_create_compound_index(CollectionHandle* handle, byte* fields_json, int unique, byte** out_name);

        /// <summary>
        ///  Drop an index
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `index_name`: Index name to drop (UTF-8 null-terminated string)
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_drop_index", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_drop_index(CollectionHandle* handle, byte* index_name);

        /// <summary>
        ///  List all indexes in a collection
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///
        ///  # Returns
        ///  - JSON array of index names (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_list_indexes", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_list_indexes(CollectionHandle* handle);

        /// <summary>
        ///  Explain query execution plan
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///
        ///  # Returns
        ///  - JSON query plan (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_explain", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_explain(CollectionHandle* handle, byte* query_json);

        /// <summary>
        ///  Find documents with index hint
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `query_json`: Query filter as JSON string
        ///  - `hint`: Index name to use
        ///
        ///  # Returns
        ///  - JSON array of documents (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_find_with_hint", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_find_with_hint(CollectionHandle* handle, byte* query_json, byte* hint);

        /// <summary>
        ///  Execute an aggregation pipeline
        ///
        ///  # Parameters
        ///  - `handle`: The collection handle
        ///  - `pipeline_json`: Aggregation pipeline as JSON array
        ///
        ///  # Returns
        ///  - JSON array of results (caller must free with `ironbase_free_string()`)
        ///  - Null on error
        ///
        ///  # Example Pipeline
        ///  ```json
        ///  [
        ///    {"$match": {"age": {"$gte": 18}}},
        ///    {"$group": {"_id": "$city", "count": {"$sum": 1}}},
        ///    {"$sort": {"count": -1}},
        ///    {"$limit": 10}
        ///  ]
        ///  ```
        ///
        ///  # Supported Stages
        ///  - `$match` - Filter documents
        ///  - `$group` - Group and aggregate
        ///  - `$project` - Reshape documents
        ///  - `$sort` - Sort results
        ///  - `$limit` - Limit result count
        ///  - `$skip` - Skip documents
        ///
        ///  # Supported Accumulators (in $group)
        ///  - `$sum` - Sum values
        ///  - `$avg` - Average values
        ///  - `$min` - Minimum value
        ///  - `$max` - Maximum value
        ///  - `$first` - First value
        ///  - `$last` - Last value
        ///  - `$count` - Count documents
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_aggregate", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_aggregate(CollectionHandle* handle, byte* pipeline_json);

        /// <summary>
        ///  Begin a new transaction
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `out_tx_id`: Pointer to receive the transaction ID
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        ///
        ///  # Usage
        ///  ```c
        ///  uint64_t tx_id;
        ///  ironbase_begin_transaction(db, &amp;tx_id);
        ///  // ... perform operations with tx_id ...
        ///  ironbase_commit(db, tx_id);
        ///  // or ironbase_rollback(db, tx_id);
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_begin_transaction", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_begin_transaction(DatabaseHandle* handle, ulong* out_tx_id);

        /// <summary>
        ///  Commit a transaction
        ///
        ///  Applies all buffered operations atomically.
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `tx_id`: The transaction ID from `ironbase_begin_transaction()`
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_commit", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_commit(DatabaseHandle* handle, ulong tx_id);

        /// <summary>
        ///  Rollback a transaction
        ///
        ///  Discards all buffered operations.
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `tx_id`: The transaction ID from `ironbase_begin_transaction()`
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_rollback", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_rollback(DatabaseHandle* handle, ulong tx_id);

        /// <summary>
        ///  Insert one document within a transaction
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `collection_name`: Collection name
        ///  - `document_json`: Document as JSON string
        ///  - `tx_id`: Transaction ID
        ///  - `out_id`: Pointer to receive the inserted ID as JSON string
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_insert_one_tx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_insert_one_tx(DatabaseHandle* handle, byte* collection_name, byte* document_json, ulong tx_id, byte** out_id);

        /// <summary>
        ///  Update one document within a transaction
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `collection_name`: Collection name
        ///  - `query_json`: Query filter as JSON string
        ///  - `new_doc_json`: New document content (full replacement)
        ///  - `tx_id`: Transaction ID
        ///  - `out_matched`: Pointer to receive matched count
        ///  - `out_modified`: Pointer to receive modified count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_update_one_tx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_update_one_tx(DatabaseHandle* handle, byte* collection_name, byte* query_json, byte* new_doc_json, ulong tx_id, ulong* out_matched, ulong* out_modified);

        /// <summary>
        ///  Delete one document within a transaction
        ///
        ///  # Parameters
        ///  - `handle`: The database handle
        ///  - `collection_name`: Collection name
        ///  - `query_json`: Query filter as JSON string
        ///  - `tx_id`: Transaction ID
        ///  - `out_deleted`: Pointer to receive deleted count
        ///
        ///  # Returns
        ///  - `IronBaseErrorCode::Success` (0) on success
        ///  - Error code on failure
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_delete_one_tx", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_delete_one_tx(DatabaseHandle* handle, byte* collection_name, byte* query_json, ulong tx_id, ulong* out_deleted);

        /// <summary>
        ///  Free a string allocated by the FFI layer
        ///
        ///  This must be called for any string returned by `ironbase_*` functions
        ///  that return `*mut c_char` (except error messages from `ironbase_get_last_error()`).
        ///
        ///  # Parameters
        ///  - `ptr`: Pointer to the string to free
        ///
        ///  # Safety
        ///  - The pointer must have been allocated by an `ironbase_*` function
        ///  - The pointer must not be used after this call
        ///  - It is safe to call with a null pointer (no-op)
        ///
        ///  # Example (C#)
        ///  ```csharp
        ///  IntPtr jsonPtr = NativeMethods.ironbase_find(handle, queryPtr);
        ///  try {
        ///      string json = Marshal.PtrToStringUTF8(jsonPtr);
        ///      // ... use json ...
        ///  } finally {
        ///      NativeMethods.ironbase_free_string(jsonPtr);
        ///  }
        ///  ```
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_free_string", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_free_string(byte* ptr);

        /// <summary>
        ///  Get the version of the IronBase FFI library
        ///
        ///  # Returns
        ///  - Version string (caller must free with `ironbase_free_string()`)
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_version", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_version();

        // ============== CURSOR API ==============

        /// <summary>
        /// Create a cursor for streaming through query results.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_create_cursor", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_create_cursor(CollectionHandle* handle, byte* query_json, uint batch_size, CursorHandle** out_cursor);

        /// <summary>
        /// Get the next document from cursor.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_next", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_cursor_next(CursorHandle* cursor);

        /// <summary>
        /// Get the next batch of documents from cursor.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_next_batch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_cursor_next_batch(CursorHandle* cursor);

        /// <summary>
        /// Get a specific chunk of documents from cursor.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_next_chunk", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_cursor_next_chunk(CursorHandle* cursor, uint chunk_size);

        /// <summary>
        /// Get remaining document count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_remaining", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong ironbase_cursor_remaining(CursorHandle* cursor);

        /// <summary>
        /// Get total document count.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_total", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong ironbase_cursor_total(CursorHandle* cursor);

        /// <summary>
        /// Get current position.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_position", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern ulong ironbase_cursor_position(CursorHandle* cursor);

        /// <summary>
        /// Check if cursor is exhausted.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_is_finished", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_cursor_is_finished(CursorHandle* cursor);

        /// <summary>
        /// Reset cursor to the beginning.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_rewind", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_cursor_rewind(CursorHandle* cursor);

        /// <summary>
        /// Skip the next N documents.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_skip", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_cursor_skip(CursorHandle* cursor, ulong n);

        /// <summary>
        /// Collect all remaining documents.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_collect_all", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_cursor_collect_all(CursorHandle* cursor);

        /// <summary>
        /// Release a cursor handle.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_cursor_release", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern void ironbase_cursor_release(CursorHandle* cursor);

        // ============== SCHEMA VALIDATION API ==============

        /// <summary>
        /// Set or clear JSON schema for a collection.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_set_collection_schema", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_set_collection_schema(DatabaseHandle* handle, byte* collection_name, byte* schema_json);

        // ============== LOGGING API ==============

        /// <summary>
        /// Set the global log level.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_set_log_level", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern int ironbase_set_log_level(byte* level);

        /// <summary>
        /// Get the current global log level.
        /// </summary>
        [DllImport(__DllName, EntryPoint = "ironbase_get_log_level", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        internal static extern byte* ironbase_get_log_level();


    }

    // Opaque handle for cursor
    [StructLayout(LayoutKind.Sequential)]
    internal struct CursorHandle { }

    // DatabaseHandle and CollectionHandle are defined in separate files as SafeHandle classes



}
